# -*- coding: utf-8 -*-
"""projeto_steganography_criptografia.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1r3Hlbu7s6nnaaUym_2AuCxWw9b5CB8E7
"""

# Primeiro, eu preciso instalar as bibliotecas que vou usar, então faço isso com o comando abaixo.
!pip install stepic cryptography

# Importo as bibliotecas que vou precisar para o projeto
import stepic  # para fazer a esteganografia nas imagens
from cryptography.hazmat.primitives.asymmetric import rsa  # para gerar as chaves públicas e privadas
from cryptography.hazmat.primitives import hashes  # para fazer o hashing das imagens
from cryptography.hazmat.primitives.asymmetric import padding  # para definir o padding da criptografia
from cryptography.hazmat.primitives import serialization  # para serializar as chaves
from PIL import Image  # para manipulação de imagens
import hashlib  # para gerar o hash das imagens e verificar alterações
import base64  # para converter o texto encriptado para base64

# Primeira coisa, vou gerar o par de chaves RSA (pública e privada) para a criptografia e decriptação
private_key = rsa.generate_private_key(public_exponent=65537, key_size=2048)
public_key = private_key.public_key()

# Função para embutir um texto em uma imagem usando esteganografia
def embed_text_in_image(image_path, text, output_path):
    # Abro a imagem com o PIL e embuto o texto
    image = Image.open(image_path)
    encoded_image = stepic.encode(image, text.encode())
    # Salvo a imagem modificada no caminho especificado pelo usuário
    encoded_image.save(output_path)
    print(f"Texto embutido na imagem e salvo em {output_path}")

# Função para extrair o texto de uma imagem que foi modificada com esteganografia
def extract_text_from_image(image_path):
    image = Image.open(image_path)
    decoded_text = stepic.decode(image)
    print(f"Texto recuperado da imagem: {decoded_text}")

# Função para gerar o hash de uma imagem, assim posso ver se houve alteração comparando os hashes
def generate_image_hash(image_path):
    # Leio a imagem em modo binário e calculo o hash SHA-256
    with open(image_path, "rb") as f:
        bytes = f.read()
        hash_value = hashlib.sha256(bytes).hexdigest()
    print(f"Hash da imagem {image_path}: {hash_value}")
    return hash_value

# Função para encriptar o texto usando a chave pública
def encrypt_text(text):
    # Criptografo o texto com a chave pública usando padding OAEP e SHA-256
    encrypted = public_key.encrypt(
        text.encode(),
        padding.OAEP(
            mgf=padding.MGF1(algorithm=hashes.SHA256()),
            algorithm=hashes.SHA256(),
            label=None
        )
    )
    encrypted_text = base64.b64encode(encrypted).decode()
    print(f"Texto encriptado: {encrypted_text}")
    return encrypted_text

# Função para decriptar o texto usando a chave privada
def decrypt_text(encrypted_text):
    # Converto o texto encriptado de volta de base64 e decripto com a chave privada
    encrypted_text = base64.b64decode(encrypted_text)
    decrypted = private_key.decrypt(
        encrypted_text,
        padding.OAEP(
            mgf=padding.MGF1(algorithm=hashes.SHA256()),
            algorithm=hashes.SHA256(),
            label=None
        )
    )
    decrypted_text = decrypted.decode()
    print(f"Texto decriptado: {decrypted_text}")
    return decrypted_text

# Criei um menu que roda em loop até o usuário digitar "S" para sair
def menu():
    while True:
        print("\nMenu de opções:")
        print("(1) Embutir texto em uma imagem (Steganography)")
        print("(2) Recuperar texto de uma imagem alterada (Steganography)")
        print("(3) Gerar hash das imagens original e alterada")
        print("(4) Encriptar texto usando chave pública")
        print("(5) Decriptar texto usando chave privada")
        print("(S) Sair")
        choice = input("Escolha uma opção: ").strip().lower()

        # Opção 1: Embutir texto em uma imagem
        if choice == '1':
            image_path = input("Caminho da imagem original: ")
            text = input("Texto a embutir: ")
            output_path = input("Caminho para salvar a imagem alterada: ")
            embed_text_in_image(image_path, text, output_path)

        # Opção 2: Recuperar texto de uma imagem modificada com esteganografia
        elif choice == '2':
            image_path = input("Caminho da imagem alterada: ")
            extract_text_from_image(image_path)

        # Opção 3: Gerar hash para comparar imagens e verificar alterações
        elif choice == '3':
            original_image_path = input("Caminho da imagem original: ")
            altered_image_path = input("Caminho da imagem alterada: ")
            print("Hash da imagem original:")
            original_hash = generate_image_hash(original_image_path)
            print("Hash da imagem alterada:")
            altered_hash = generate_image_hash(altered_image_path)

            # Comparação entre hashes
            if original_hash != altered_hash:
                print("A imagem foi alterada.")
            else:
                print("A imagem não foi alterada.")

        # Opção 4: Encriptar texto com a chave pública
        elif choice == '4':
            text = input("Texto a encriptar: ")
            encrypted_text = encrypt_text(text)
            print("Texto encriptado com sucesso. Use essa string para embutir na imagem com a opção (1).")

        # Opção 5: Decriptar texto usando a chave privada
        elif choice == '5':
            encrypted_text = input("Texto encriptado: ")
            decrypted_text = decrypt_text(encrypted_text)
            print(f"Texto decriptado: {decrypted_text}")

        # Opção S: Sair do menu
        elif choice == 's':
            print("Saindo...")
            break
        else:
            print("Opção inválida. Tente novamente.")

# Chamo a função para exibir o menu e rodar o programa
menu()

